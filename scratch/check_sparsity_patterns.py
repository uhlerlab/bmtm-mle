''' 
Used this script to uncover patterns in the sparisty of our MLE
Hypotheses are encoded as predict_* functions
Run on json files generated by generate_mle.py
'''
import argparse
import json
import math

from statistics import median

import numpy as np
from tqdm import tqdm

from scratch.tree import Tree
from util import * 

def predict_tree_two(data):
    if (data[0] > 0) != (data[1] > 0):
        return (True, False, False)
    if abs(data[0]) < abs(data[1]):
        return (False, True, False)
    return (False, False, True)

def predict_four_star(data):
    line = sorted(data+[0])
    scores = sorted([(math.prod(1/math.sqrt(abs(a-b)) for b in line if a != b), a) for a in line])
    min_elem = scores[-1][1]
    print(scores)
    print(min_elem)
    if min_elem == 0:
        return (True, False, False, False, False)
    
    ans = [False]*4
    ans[data.index(min_elem)] = True
    return (False,)+tuple(ans)

def predict_tree_three_star(data):
    abs_l = ((abs(a), i) for i, a in enumerate(data))
    sort_abs = sorted(abs_l)

    sides = [a > 0 for a in data]

    if all(s == sides[0] for s in sides):
        ans =  [False]*4
        if abs(sort_abs[1][0]) < abs(sort_abs[2][0]) - abs(sort_abs[0][0]):
            ans[sort_abs[0][1]+1] = True
        else:
            ans[sort_abs[1][1]+1] = True

        return tuple(ans)

    dom_side = sum(int(a)*2-1 for a in sides)
    ordered_by_dom_side = sorted((dom_side*a, a, i) for i, a in enumerate(data))
    max_dom, max_dom_i = ordered_by_dom_side[-1][1:]
    mid_dom, mid_dom_i = ordered_by_dom_side[-2][1:]
    other_side, other_side_i = ordered_by_dom_side[0][1:]

    if abs(other_side) < abs(max_dom) - abs(mid_dom):
        return (True, False, False, False)

    ans =  [False]*4
    ans[mid_dom_i+1] = True
    return tuple(ans)

def predict_tree_three_sym(data):
    if (data[0] > 0) != (data[1] > 0):
        return (True, False, False)
    if abs(data[0]) < abs(data[1]):
        return (False, True, False)
    return (False, False, True)

def predict_tree_three_asym(data):
    abs_l = (abs(a) for a in data)
    sort_abs = sorted(abs_l)
    if (data[1] > 0) != (data[2] > 0):
        ordered_by_dom_side = sorted((math.copysign(1, data[0])*a, a) for a in data)
        max_dom = ordered_by_dom_side[-1][1]
        mid_dom = ordered_by_dom_side[-2][1]
        other_side = ordered_by_dom_side[0][1]
        if abs(max_dom) > abs(mid_dom) + abs(other_side):
           return (True, False, True, False, False)
        else:
            if mid_dom == data[0]:
                return (False, True, True, False, False)
            elif mid_dom == data[1]:
                return (False, False, True, True, False)
            elif mid_dom == data[2]:
                return (False, False, True, False, True)
    else:
        if (data[0] > 0) != (data[1] > 0):
            if abs(data[1]) < abs(data[2]):
                return (True, False, False, True, False)
            else:
                return (True, False, False, False, True)

        else:
            if abs(data[0]) == sort_abs[0]:
                if abs(data[1]) == sort_abs[1]:
                    return (False, True, False, True, False)
                else:
                    return (False, True, False, False, True)
            elif abs(data[0]) == sort_abs[1]:
                if sort_abs[0] < sort_abs[2] - sort_abs[1]: # if smallest is close enough to zero, then make parent
                    if abs(data[1]) == sort_abs[0]:
                        return (False, False, True, True, False)
                    else:
                        return (False, False, True, False, True)
                else:
                    return (False, True, True, False, False)

            elif abs(data[0]) == sort_abs[2]:
                if sort_abs[0] < sort_abs[2] - sort_abs[1]: # min wins
                    if abs(data[1]) == sort_abs[0]:
                        return (False, False, True, True, False)
                    else:
                        return (False, False, True, False, True)
                else: # mid wins
                    if abs(data[1]) == sort_abs[1]:
                        return (False, False, True, True, False)
                    else:
                        return (False, False, True, False, True)

def predict_tree(data, structure):
    if tuple(structure) == (0, 0):
        return predict_tree_two(data)
    if tuple(structure) == (0, 2, 0, 0):
        return predict_tree_three_asym(data)
    if tuple(structure) == (0, 0, 0):
        return predict_tree_three_star(data)
    if tuple(structure) == (0, 0, 0, 0):
        return predict_four_star(data)
    
    raise ValueError('Structure not supported')

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--in_file', type=str, default='res_file_1000_0-2-0-0.json')
    args = parser.parse_args()

    with open(args.in_file, 'r') as res_file:
        file_dict = json.load(res_file)
        tree = Tree()  
        tree.make_prefix(file_dict['structure'])

        buckets = {}
        for i, res in enumerate(tqdm(file_dict['results'])):
            data, mle = res
            if is_data_invalid(data):
                print('Invalid')
                continue
            tree.set_data(data)
            tree.set_var(mle)

            def compare_patterns(one, two):
                if one is None or two is None:
                    return True
                print('Running')
                return all(a == b or a is None or b is None for a, b in zip(one, two))
            if not compare_patterns(predict_tree(data, file_dict['structure']), tree.zero_pattern()):
                print('Recomputing...', data, mle, tree.zero_pattern(), predict_tree(data, file_dict['structure']))
                best_l = tree.likelihood()
                print('Initial likelihood', best_l)
                mle = tree.mle(method='dual_annealing', max_var=max_var(data), accept=-1000, maxiter=5000)
                print('Current likelihood', tree.likelihood())
                if not compare_patterns(predict_tree(data, file_dict['structure']), tree.zero_pattern()):
                    print('New mle', mle, tree.zero_pattern())
                    best_l = max(best_l, tree.likelihood())
                    mle = tree.mle(method='dual_annealing', max_var=max_var(data), accept=-4000, maxiter=10000)
                    if not compare_patterns(predict_tree(data, file_dict['structure']), tree.zero_pattern()):
                        print('New mle', mle, tree.zero_pattern())
                        raise ValueError('Mismatch')
                    elif tree.likelihood() < best_l:
                        print('New mle', mle, tree.zero_pattern())
                        raise ValueError('Match but lower likelihood')
                elif tree.likelihood() < best_l:
                    print('New mle', mle, tree.zero_pattern())
                    raise ValueError('Match but lower likelihood')

        file_dict['results'][i] = [data, list(mle)]